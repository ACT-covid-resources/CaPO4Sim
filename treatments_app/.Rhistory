#
# Later modifications by Paul Hurtado:
#   * Overhaul as a shiny app: http://shiny.rstudio.com/gallery/widget-gallery.html
#      + Modified functions so that all use input functions of the form: fun(x,y,parms)
#
# Missing Features (TTD):
#
#   * A mechanism to "reset" following an equation or parameter change,
#     that erases all fixed points, S/U manifolds of saddles, trajectories, etc.
#
#   * Better time step size and integration length controls.
#
#   * Allow user defined labels and colors...  E.g. default colors should
#     match colors from the matlab version of pplane (personal preference!)
#
#   * Legend on GUI for fixed point symbols (saddle, source, node, etc.)
#
#   * Do these revised functions work as "command line" tools like SPE's version?
#     If not, go back and implement wrappers so we can have a unified package!
#      + Ultimately, aim for a shiny/GUI version and command line version.
#      + Once that exists, write documentation, put it all in an R package.
#
#   Inspired by pplane (for Matlab) at http://math.rice.edu/~dfield/
#
##########################################################################################
## These functions assume a function of the form
##    fun <- function(x,y,p) { with(as.list(p), { c(dx,dy) } ) }
## When we need to use fun with deSolve::ode() we must first convert it via this function:
as.ode.func = function(FUN) { return(function(t,y,parms){list(FUN(y[1],y[2],parms))}) }
##########################################################################################
## Functions for drawing 2D state space / vector field / phase plane plots
## Documentation will be coming soon!! :-)
## Split this into phasearrows.calc() and phasearrows.draw()
phasearrows <- compiler::cmpfun(function(fun,xlims,ylims,resol=25, col='black', add=F,parms=NULL) {
if (add==F) {
plot(1,xlim=xlims, ylim=ylims, type='n',xlab="x",ylab="y");
}
x <- matrix(seq(xlims[1],xlims[2], length=resol), byrow=T, resol,resol);
y <- matrix(seq(ylims[1],ylims[2], length=resol),byrow=F, resol, resol);
npts <- resol*resol;
# Removed by PJH so drawing phase arrows twice doesn't change the figure...
#  xspace <- abs(diff(xlims))/(resol*10);
#  yspace <- abs(diff(ylims))/(resol*10);
#  x <- x + matrix(runif(npts, -xspace, xspace),resol,resol);
#  y <- y + matrix(runif(npts, -yspace, yspace),resol,resol);
z <- fun(x,y,parms);
z1 <- matrix(z[1:npts], resol, resol);
z2 <- matrix(z[(npts+1):(2*npts)], resol, resol);
maxx <- max(abs(z1));
maxy <- max(abs(z2));
dt <- min( abs(diff(xlims))/maxx, abs(diff(ylims))/maxy)/resol;
lens <- sqrt(z1^2 + z2^2);
lens2 <- lens/max(lens); ## Can this next line be more robust? Change .1 to ???
arrows(c(x), c(y), c(x+dt*z1/((lens2)+.1)), c(y+dt*z2/((lens2)+.1)),length=.04, col=col);
})
vec.data<<-list()
phasearrows.calc <- compiler::cmpfun(function(fun,xlims,ylims,resol=25,parms=NULL) {
#if (add==F) {
#  plot(1,xlim=xlims, ylim=ylims, type='n',xlab="x",ylab="y");
#}
x <- matrix(seq(xlims[1],xlims[2], length=resol), byrow=T, resol,resol);
y <- matrix(seq(ylims[1],ylims[2], length=resol),byrow=F, resol, resol);
npts <- resol*resol;
z <- fun(x,y,parms);
z1 <- matrix(z[1:npts], resol, resol);
z2 <- matrix(z[(npts+1):(2*npts)], resol, resol);
maxx <- max(abs(z1));
maxy <- max(abs(z2));
dx <- min( abs(diff(xlims))/maxx, abs(diff(ylims))/maxy)/resol;
lens <- sqrt(z1^2 + z2^2);
lens2 <- lens/max(lens);
return(list(x,y,z1,z2,lens2,dx)) # save as vec.data
})
phasearrows.draw <- compiler::cmpfun(function(vfdat=vec.data, col="black") {
x <- vfdat[[1]]
y <- vfdat[[2]]
z1<- vfdat[[3]]
z2<- vfdat[[4]]
lens2<- vfdat[[5]]
dx <- vfdat[[6]]
## Can this next line be more robust? Change .1 to 1e-6? Change 0.04 to ???
arrows(c(x), c(y), c(x+dx*z1/((lens2)+.1)), c(y+dx*z2/((lens2)+.1)),length=.04, col=col);
})
## REMOVE THIS OR NOT???
showcontours <- compiler::cmpfun(function(fun,xlims, ylims,resol=250,add=F, colors=c('red', 'blue'),parms=NULL) {
x <- matrix(seq(xlims[1],xlims[2], length=resol), byrow=F, resol,resol);
y <- matrix(seq(ylims[1],ylims[2], length=resol),byrow=T, resol, resol);
npts = resol*resol;
z <- fun(x,y,parms);
z1 <- matrix(z[1:npts], resol, resol);
z2 <- matrix(z[(npts+1):(2*npts)], resol, resol);
contour(x[,1],y[1,],z1, add=add, col=colors[1]);
contour(x[,1],y[1,],z2, add=T, col=colors[2]);
})
##  Split into nullclines.calc() and nullclines.draw()
nullclines <- compiler::cmpfun(function(fun,xlims, ylims, resol=250, add=F,parms=NULL) {
x <- matrix(seq(xlims[1],xlims[2], length=resol), byrow=F, resol,resol);
y <- matrix(seq(ylims[1],ylims[2], length=resol),byrow=T, resol, resol);
npts = resol*resol;
z <- fun(x,y,parms);
z1 <- matrix(z[1:npts], resol, resol);
z2 <- matrix(z[(npts+1):(2*npts)], resol, resol);
contour(x[,1],y[1,],z1,levels=c(0), drawlabels=F,add=add, col="orange");
contour(x[,1],y[1,],z2,levels=c(0), drawlabels=F,add=T, col="magenta");
title(main="Orange = x nullcline, Magenta = y nullcline",cex=0.35);
})
nullclines.data <- list()
nullclines.calc <- compiler::cmpfun(function(fun,xlims,ylims,resol=250,parms=NULL) {
x <- matrix(seq(xlims[1],xlims[2], length=resol), byrow=F, resol,resol);
y <- matrix(seq(ylims[1],ylims[2], length=resol),byrow=T, resol, resol);
npts = resol*resol;
z <- fun(x,y,parms);
z1 <- matrix(z[1:npts], resol, resol);
z2 <- matrix(z[(npts+1):(2*npts)], resol, resol);
return(list(x,y,z1,z2)) # return nullclines.data
})
nullclines.draw <- compiler::cmpfun(function(ndat=nullclines.data,add=T){
x <- ndat[[1]]
y <- ndat[[2]]
z1<- ndat[[3]]
z2<- ndat[[4]]
contour(x[,1],y[1,],z1,levels=c(0), drawlabels=F,add=add, col="orange");
contour(x[,1],y[1,],z2,levels=c(0), drawlabels=F,add=T, col="magenta");
#title(main="Orange = x nullcline, Magenta = y nullcline",cex=0.35);
})
## We need something like an array or list for each trajectory, that we can add to.
## BETA VERSION: Don't track time. Add that in later once it all works?
##
## 1. Structure to save curves: traj.data
traj.data=list() # each element will be an Mx3 matrix like cbind(time,x,y)
## 2. Function to plot them all. Allow ability to pass args to ode() via ...
traj.draw = function(tdat=traj.data,col="blue",lwd=2) {
#print(unlist(tdat[[1]]))
for(i in 1:length(tdat)) {
lines(tdat[[i]][,2:3], lwd=lwd, col=col)}
}
## 3. grid.calc()
grid.calc <- compiler::cmpfun(function(fun,xlim,ylim,parms,ngrid,maxtime=50) {
xvals=seq(xlim[1],xlim[2],length=ngrid);
yvals=seq(ylim[1],ylim[2],length=ngrid);
ts <- list()
for(i in 1:ngrid) {
for(j in 1:ngrid) {
out1=ode(times=  seq(0,maxtime,length=500),y=c(xvals[i],yvals[j]),func=as.ode.func(fun),parms=parms);
out2=ode(times= -seq(0,maxtime,length=500),y=c(xvals[i],yvals[j]),func=as.ode.func(fun),parms=parms);
ts[[length(ts)+1]] <- rbind(out2[nrow(out2):2 , ],out1)
}}
return(ts)
})
## 4. traj.forward() and traj.backward()
traj.forward  = compiler::cmpfun(function(x0,fun,parms,maxtime,Tlen=500,...){
out=ode(times=seq(0,maxtime,length=Tlen),y=c(x0[1],x0[2]),func=as.ode.func(fun),parms=parms,...);
return(out);
})
traj.backward = compiler::cmpfun(function(x0,fun,parms,maxtime,Tlen=500,...){
out=ode(times=seq(0,-maxtime,length=Tlen),y=c(x0[1],x0[2]),func=as.ode.func(fun),parms=parms,...);
return(out[nrow(out):1,]);
})
## 5. traj.continue()
traj.continue <- compiler::cmpfun(function(fun, parms, tdat, maxtime, Tlen=500, backward=FALSE, ...){
if(length(tdat)==0) { cat("WARNING: No trajectories have been calculate yet!\n")}
out.curr <- tdat[[length(tdat)]]
if(backward) {
X0=head(out.curr,1);
t0=X0[1];
x0=X0[-1];
times=t0+seq(0,-maxtime,length=Tlen);
out=ode(times=times,y=x0,func=as.ode.func(fun),parms=parms,...);
return(rbind(out[nrow(out):2,],out.curr));
} else {
X0=tail(out.curr,1);
t0=X0[1]
x0=X0[-1]
times=t0+seq(0,maxtime,length=Tlen);
out=ode(times=times,y=x0,func=as.ode.func(fun),parms=parms,...);
return(rbind(out.curr,out[-1,]));
}
})
## original grid() function
grid=compiler::cmpfun(function(fun,xlim,ylim,parms,ngrid,maxtime=50,Tlen=500,add=F,color="blue") {
if (add==F) {
plot(1,xlim=xlim, ylim=ylim, type='n',xlab="x",ylab="y");
}
xvals=seq(xlim[1],xlim[2],length=ngrid);
yvals=seq(ylim[1],ylim[2],length=ngrid);
for(i in 1:ngrid) {
for(j in 1:ngrid) {
out=ode(times=seq(0,maxtime,length=Tlen),y=c(xvals[i],yvals[j]),func=as.ode.func(fun),parms=parms);
points(out[,2],out[,3],type="l",lwd=2,col=color);
out=ode(times=-seq(0,maxtime,length=Tlen),y=c(xvals[i],yvals[j]),func=as.ode.func(fun),parms=parms);
points(out[,2],out[,3],type="l",lwd=2,col=color);
}}
})
# Newton's method to find equilibria of vector field.
# func() must have the same input arguments and returns as for ode/rk4.
# Inputs:
#   x0 = intial guess at equilibrium. If x0 is not supplied in the call,
#        the user chooses it from the current graphics device via locator()
#         and the equilibrium is plotted to the same device. Plotting
#         symbol is closed/open=stable/unstable, circle/triangle=eigenvalues imaginary/real.
#   tol= Convergence tolerance
#   niter = Maximum number of iterations
#   inc = finite-difference increment for derivative estimates
# Coded 5/25/06 by SPE based on Matlab toggle.m by JG
# MODIFIED 7/2016 by PJH to take functions fun(x,y,parms)
newton=compiler::cmpfun(function(fun,x0=NULL,parms=NULL,tol=1e-16,niter=40,inc=1e-6,plotit=TRUE) {
x=x0; #initial x
if (is.null(x0)) {
warning("Oops! newton() was called without x0 specified!");#{x = locator(n=1); x=c(x$x,x$y)};
return(list(x=c(NA,NA,df=matrix(NA,2,2),pch=NA)))
}
nx = length(x); # length of state vector
######### Newton iteration loop: start
for(i in 1:niter){
y = as.ode.func(fun)(0,x,parms)[[1]]
df = matrix(0,nx,nx); # Compute df
for(j in 1:nx) {
#Increment vector for estimating derivative wrt jth coordinate
v=rep(0,nx);
v[j] = inc;
df[,j]=  (as.ode.func(fun)(t,x+v,parms)[[1]] - as.ode.func(fun)(t,x-v,parms)[[1]])/(2*inc)
}
if (sum(y^2) < tol){  #check for convergence
if(plotit){
ev=eigen(df)$values; pch1=1+as.numeric(Im(ev[1])!=0); pch2=1+as.numeric(max(Re(ev))<0);
pchs=matrix( c(2,17,1,16),2,2,byrow=T);
#points(x[1],x[2],type="p",pch=pchs[pch1,pch2],cex=1.5)
}
cat("Fixed point (x,y) = ",x,"\n");
cat("Jacobian Df=","\n"); print(df);cat("Eigenvalues","\n"); print(eigen(df)$values)
return(list(x=x,df=df,pch=pchs[pch1,pch2]))
} # end convergence check
x = x - solve(df,y) # one more step if needed
cat(i, x, "\n") #print out the next iterate
}
######### Newton iteration loop: end
cat("Convergence failed");
})
## to draw fixed points
fixed.points.draw <- compiler::cmpfun(function(FPs) {
for(i in 1:length(FPs)) { points(FPs[[i]]$x[1], FPs[[i]]$x[2], cex=1.5, type="p",pch=FPs[[i]]$pch)}
})
manifolds.calc <- compiler::cmpfun(function(fun,parms,FPs,maxtime=250, Tlen=500) {
ms = list()
for(i in 1:length(FPs)) { if(!any(is.na(FPs[[i]]$x))) {
x=FPs[[i]]$x; df=FPs[[i]]$df; V=eigen(df)$vectors; ev=eigen(df)$values;
if (sign(Re(ev[1])) != -sign(Re(ev[2])) | Im(ev[1]) != 0) {
# if not a saddle...
ms[[i]] <- list(S=matrix(NA,nrow=1,ncol=2),U=matrix(NA,nrow=1,ncol=2))
}else{
i1=which(Re(ev)>0); i2=which(Re(ev)<0);
v1=V[,i1]; v2=V[,i2]; eps=1e-3;
out1=ode(y=x+eps*v1,times=seq(0,maxtime,length=Tlen),func=as.ode.func(fun),parms=parms);
out2=ode(y=x-eps*v1,times=seq(0,maxtime,length=Tlen),func=as.ode.func(fun),parms=parms);
out3=ode(y=x+eps*v2,times=-seq(0,maxtime,length=Tlen),func=as.ode.func(fun),parms=parms);
out4=ode(y=x-eps*v2,times=-seq(0,maxtime,length=Tlen),func=as.ode.func(fun),parms=parms);
S = rbind(out3,out4[1,]*NA,out4)[,-1]
U = rbind(out1,out2[1,]*NA,out2)[,-1]
ms[[i]] <- list(S=S,U=U)
}} else { # if x[1] is NA...
ms[[i]] <- list(S=matrix(NA,nrow=1,ncol=2),U=matrix(NA,nrow=1,ncol=2))
}
}
return(ms)
})
manifolds.draw=compiler::cmpfun(function(ms) {
for(i in 1:length(ms)){
S=ms[[i]]$S
U=ms[[i]]$U
title(sub="Black=stable manifold, Red=unstable manifold");
points(S[,1],S[,2],type="l",lwd=2,col="black");
points(U[,1],U[,2],type="l",lwd=2,col="red");
}
})
# Compute Jacobian of a planar vector field at a point (x,y),
# either input or chosen with locator().
jacobianAtXY <- compiler::cmpfun(function(fun,x=NULL, y=NULL,inc=1e-7){
if (is.null(x)|is.null(y)) {
x0 <- locator(n=1); x <- x0$x; y <- x0$y;
}
foo <- fun(x,y); h = inc;
foox <- fun(x+h,y); fooy <- fun(x,y+h);
A <- (foox[1] - foo[1])/h;
B <- (fooy[1] - foo[1])/h;
C <- (foox[2] - foo[2])/h;
D <- (fooy[2] - foo[2])/h;
return(matrix( c(A,B,C,D ),2,2,byrow=T))
})
################################################################################################
## Next, define the user interface and server functions for the shiny app (aka the GUI version)
################################################################################################
# Define server logic required to plot various variables
server <- function(input, output) {
xlim <- reactive({ xlim <- c(input$xmin,input$xmax) })
ylim <- reactive({ ylim <- c(input$ymin,input$ymax) })
# Let user define variables and ODE equations
xlab <- reactive({ xlab <- input$x})
ylab <- reactive({ ylab <- input$y})
# These MUST be called from within a reactive environment!
parms <- function() { eval(parse(text=paste0("parms <- c(",input$ps,")"))) }
fn   <- function() { eval(parse(text=paste0("fun <<- function(",input$x,",",input$y,", ps) { with(as.list(ps),{c(",input$dx,",",input$dy,")}) }")))}
ngrid <- reactive({ ngrid <- input$ngrid })
maxtime <- reactive({ maxtime <- input$maxtime })
show.nullclines  <- reactive({show.nullclines <- input$show.nullclines })
show.arrows      <- reactive({show.arrows <- input$show.arrows })
show.fps         <- reactive({show.fps <- input$show.fps })
show.SUmanifolds <- reactive({show.SUmanifolds <- input$show.SUmanifolds })
show.trajectories<- reactive({show.trajectories <- input$show.trajectories })
xy_coords <- reactive({input$plot_click})
# Reactive Values...
rv <- reactiveValues()
# store fixed points and pch/symbol here.
rv$fps <- list(list(x=c(NA,NA),df=matrix(NA,2,2),pch=NA))
# store S/U manifolds of saddles
rv$SU <- list(list(S=matrix(NA,nrow=1,ncol=2),U=matrix(NA,nrow=1,ncol=2)))
# store trajectories.
rv$traj <- list((matrix(NA,nrow=2,ncol=3)))
# To display the coordinates for plot clicks on the user interface...
output$plot_click_coords_fp <- renderText({
paste0("x=", xy_coords()$x, "\ny=", xy_coords()$y)
})
output$plot_click_coords_traj <- renderText({
paste0("x=", xy_coords()$x, "\ny=", xy_coords()$y)
})
# button click to find fixed point...
observeEvent(input$fp_button, {
rv$fps[[length(rv$fps)+1]] <<- newton(fn(),x0=c(xy_coords()$x,xy_coords()$y), parms=parms());
rv$SU <<- manifolds.calc(fn(),parms=parms(),rv$fps, maxtime=maxtime())
})
# clear all fixed points
observeEvent(input$fp_clear_button, {
rv$fps <- list(list(x=c(NA,NA),df=matrix(NA,2,2),pch=NA))
rv$SU <- list(list(S=matrix(NA,nrow=1,ncol=2),U=matrix(NA,nrow=1,ncol=2)))
})
# button to compute and plot forward trajectory starting at mouse click...
observeEvent(input$forward_button, {
if(!is.null(xy_coords()$x))
rv$traj[[length(rv$traj)+1]] <<- traj.forward(x0=c(xy_coords()$x,xy_coords()$y),fn(),parms=parms(),maxtime());
})
# button to compute and plot backward trajectory starting at mouse click...
observeEvent(input$backward_button, {
rv$traj[[length(rv$traj)+1]] <<- traj.backward(x0=c(xy_coords()$x,xy_coords()$y),fn(),parms=parms(),maxtime());
})
# button to extend last trajectory forward starting at mouse click...
observeEvent(input$extend_forward_button, {
rv$traj[[length(rv$traj)]] <<- traj.continue(fun=fn(), parms=parms(), rv$traj,maxtime());
})
# button to extend last trajectory backward starting at mouse click...
observeEvent(input$extend_backward_button, {
rv$traj[[length(rv$traj)]] <<- traj.continue(fun=fn(), parms=parms(), rv$traj,maxtime(),backward=TRUE);
})
# button to plot a grid of trajectories
observeEvent(input$grid_button, {
rv$traj <<- append(rv$traj, grid.calc(fn(),xlim(),ylim(),parms(),ngrid(),maxtime()) )
print(length(rv$traj))
})
# button to clear all trajectories
observeEvent(input$traj_clear_button, {
rv$traj <- list((matrix(NA,nrow=2,ncol=3)))
print(length(rv$traj))
})
output$PPlot <- renderPlot({
plot(NA,xlim=xlim(), ylim=ylim(), type='n',xlab=input$x,ylab=input$y);
# Slower, but just recalculate these each time we redraw the plot...
vec.data <<- phasearrows.calc(fun=fn(),xlims=xlim(),ylims=ylim(),parms=parms())
nullclines.data <<- nullclines.calc(fun=fn(),xlims=xlim(),ylims=ylim(),parms=parms())
if(show.arrows()) phasearrows.draw();
if(show.nullclines()) nullclines.draw();
if(show.SUmanifolds()) { manifolds.draw(rv$SU)};
if(show.fps()) { fixed.points.draw(rv$fps) };
if(show.trajectories()) { traj.draw(rv$traj) };
}, height=700, width=700)
}
## Some bells and whistles for the UI
#### This would allow side-by-side small input fields
#### Source: http://stackoverflow.com/questions/20637248/shiny-4-small-textinput-boxes-side-by-side
ui <- pageWithSidebar(
# Application title
headerPanel("Rpplane"),
# Sidebar with controls
sidebarPanel(
h4("Plot components:"),
## Reformat to make these horizontal
checkboxInput("show.nullclines", "Nullclines", TRUE),
checkboxInput("show.arrows", "Vector Field", TRUE),
checkboxInput("show.fps", "Fixed Points", FALSE),
checkboxInput("show.SUmanifolds", "Saddle Manifolds", FALSE),
checkboxInput("show.trajectories", "Trajectories", TRUE),
selectInput(
"userAction","Use the following menu to compute plot components that require user input (e.g. a mouse click on the plot):",
c("Define axis limits, integration lengths, etc."="setup",
"Find Fixed Points"="fixedpoint",
"Plot Trajectories"="traj")),
# These could use some customization to make them more compact!
conditionalPanel(condition = "input.userAction == 'setup'",
textInput("x", label = h5("x var: "), value = "u"),
textInput("y", label = h5("y var: "), value = "v"),
textInput("dx", label = h5("dx/dt"), value = "-u + a/(1+v^b)"),
textInput("dy", label = h5("dy/dt"), value = "-v + a/(1+u^c)"),
textInput("ps", label = h5("Parameters (Ex: a=1, b-2, c=3)"), value = "a=3,b=2,c=2"),
hr(),
numericInput("xmin","xmin:",0),
numericInput("xmax","xmax:",3),
numericInput("ymin","ymin:",0),
numericInput("ymax","ymax:",3)),
conditionalPanel(condition = "input.userAction == 'fixedpoint'",
h5("Instructions: Use your mouse to click on (or near) the suspected fixed point."),
verbatimTextOutput("plot_click_coords_fp"),
actionButton("fp_button","Find Nearest Fixed Point"),
actionButton("fp_clear_button","Clear All")),
conditionalPanel(condition = "input.userAction == 'traj'",
h5("Instructions: Begin a trajectory at a specific location by clicking on the plot."),
verbatimTextOutput("plot_click_coords_traj"),
numericInput("maxtime", "Integration Time:", 250), ## add separate Tmax and Tlen?
actionButton("forward_button","Forward Trajectory"),
actionButton("extend_backward_button","Extend Backward"),
actionButton("grid_button","Grid Plot"),
actionButton("backward_button","Backward Trajectory"),
actionButton("extend_forward_button","Extend Forward"),
actionButton("traj_clear_button","Clear All"),
hr(),
numericInput("ngrid","Specify number of trajectories in an nxn grid (specify n):",7))
),###########################################################
# Show the plot of the requested variable against mpg
mainPanel(h1("2D State Space (Phase Plane) Plot"),
plotOutput("PPlot",click = 'plot_click')
)
)
## No longer needed in the shiny version! Only needed if writing a script using
## the various functions defined at the start of this script, above server().
#######################################################################################
## SPECIFY MODEL AND INITIALIZE
#
## toggle switch function for phase arrow and nullcline plotting
#toggle=compiler::cmpfun(function(u,v,parms) {
#  c( -u + parms[1]/(1+v^parms[2]), -v + parms[1]/(1+u^parms[3]) )
#})
#fun=toggle ## Our generic name for the system of equations to look at! ;-)
#
## toggle switch function for computing solution trajectories with deSolve::ode()
#Toggle = as.ode.func(toggle)
#
## parameter values?
#parms=c(3,2,2)
#
## END MODEL SPECIFICATION AND INITIALIZATION
#######################################################################################
shinyApp(ui=ui, server=server)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shinyWidgets::shinyWidgetsGallery()
runApp()
library(shiny)
# Define UI for application that draws a histogram
ui <- shinyUI(fluidPage(
tags$style("
body {
-moz-transform: scale(0.8, 0.8); /* Moz-browsers */
zoom: 0.8; /* Other non-webkit browsers */
zoom: 80%; /* Webkit browsers */
}
"),
# Application title
titlePanel("Old Faithful Geyser Data"),
# Sidebar with a slider input for number of bins
sidebarLayout(
sidebarPanel(
sliderInput("bins",
"Number of bins:",
min = 1,
max = 50,
value = 30)
),
# Show a plot of the generated distribution
mainPanel(
plotOutput("distPlot")
)
)
))
# Define server logic required to draw a histogram
server <- shinyServer(function(input, output) {
output$distPlot <- renderPlot({
# generate bins based on input$bins from ui.R
x    <- faithful[, 2]
bins <- seq(min(x), max(x), length.out = input$bins + 1)
# draw the histogram with the specified number of bins
hist(x, breaks = bins, col = 'darkgray', border = 'white')
})
})
# Run the application
shinyApp(ui = ui, server = server)
